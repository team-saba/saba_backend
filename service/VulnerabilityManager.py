import datetime
import json
import logging
import re
import uuid
from typing import Union

import diskcache
import requests

from DTO.VulnerabilityRequest import VulnerabilityRequest
from DTO.VulnerabilityProcessElement import VulnerabilityProcessElement
from DTO.VulnerabilityQueue import VulnerabilityQueue
from common.dumper import dumper
import service.image_service as manage

class VulnerabilityManager:

    def __init__(self):
        self.worker_status = diskcache.Cache(directory="./cache/worker_status")
        self.scan_result = diskcache.Cache(directory="./cache/scan_result")

    def queue(
            self,
            imageId: str,
            scan_on_trivy: bool,
            scan_on_clair: bool,
    ):
        # list = manage.get_image_list()
        list = manage.print_list()
        target_image = [i for i in list if i['Name'] == imageId]

        if len(target_image) == 0:
            return
        else:
            # There is only one 'target_image' or nothing.
            target_image = target_image[0]
        # target_image['RepoDigests'][0]  #=> ruby@sha256:0123456abcde...
        # What I want is just 'ruby', or 'sha256:0123456abcde...'
        digest = ''
        if len(target_image['RepoDigests']) == 0:
            is_local_image = True
            repository_name = target_image['RepoTags'][0].split(':')[0]
            repository_url = 'localhost:5000/'

            try:
                res = requests.get('http://localhost:5000/v2/_catalog')
                if res.status_code != 200:
                    logging.warning('localhost:5000 returns ' + str(res.status_code))
            except requests.ConnectionError:
                try:
                    res = requests.get('http://registry:5000/v2/_catalog')
                    repository_url = 'http://registry:5000/'
                    if res.status_code != 200:
                        logging.warning('registry:5000 returns ' + str(res.status_code))
                except requests.ConnectionError:
                    scan_on_clair = False

        else:
            repo_digest_splitted = target_image['RepoDigests'][0].split('@')
            repository_name = repo_digest_splitted[0]
            is_local_image = False

            # This will resolve the case if image is not in the docker hub
            # like:
            #   localhost:5000/.../...
            #   192.168.100.123/.../...
            #   quay.io/.../...
            repository_url_reg = re.compile('(localhost|\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}|\\w+\\.\\w+)(:\\d+)?\\/', re.IGNORECASE)
            repository_url_search = repository_url_reg.search(repository_name)
            if repository_url_search is not None:
                repository_url = repository_url_search.group()
                repository_name = repository_name.replace(repository_url, '')
            else:
                repository_url = 'registry-1.docker.io/'

            digest = repo_digest_splitted[1]

        if repository_name.find('/') == -1:
            repository_name = 'library/' + repository_name


        queue = VulnerabilityQueue(
            uuid=uuid.uuid4().hex,
            imageId=imageId,
            repo_name=repository_name,
            digest=digest,
            scan_on_trivy=scan_on_trivy,
            scan_on_clair=scan_on_clair,
            registry_url=repository_url,
            is_local_image=is_local_image,
            result=[],
        )

        self.worker_status.set(f"Vulnerability_{queue.uuid}", queue, expire=3600)

        return

    def get_queue(self):
        result = []
        for key in self.worker_status.iterkeys():
            if key.startswith("Vulnerability_"):
                vulnerability: VulnerabilityQueue = self.worker_status.get(key=key)
                if vulnerability is None:
                    self.worker_status.delete(key=key)
                    continue

                result.append({
                    "uuid": vulnerability.uuid,
                    "imageId": vulnerability.imageId,
                    "result": vulnerability.result
                })

        return json.loads(json.dumps(result))

    def get_vulnerability(self, key) -> Union[dict, None]:
        vulnerability: VulnerabilityQueue = self.worker_status.get(f"Vulnerability_{uuid}")
        if vulnerability is None:
            self.worker_status.delete(key=key)
            return None

        return {
            "uuid": vulnerability.uuid,
            "imageId": vulnerability.imageId,
            "result": vulnerability.result
        }

    def get_scan_result(self, image_id: str):
        for key in self.scan_result.iterkeys():
            if key.startswith("Vulnerability_"):
                if image_id in key.replace("Vulnerability_", ""):
                    return self.scan_result.get(key=key)

    def get_list(self):
        list = manage.print_list()
        result = []
        for i in list:
            i['vulnerability'] = self.get_scan_result(i['Name'])
            if i['vulnerability'] is not None:
                now = datetime.datetime.now()
                i['scan_date'] = now.strftime('%Y-%m-%d %H:%M:%S')
            else:
                i['scan_date'] = None
            i['state'] = 'not scanned'
            result.append(i)
        return json.loads(json.dumps(result, default=dumper))

    pass
