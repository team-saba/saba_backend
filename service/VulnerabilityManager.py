import datetime
import json
import logging
import uuid
from typing import Union

import diskcache
import requests

from DTO.VulnerabilityRequest import VulnerabilityRequest
from DTO.VulnerabilityProcessElement import VulnerabilityProcessElement
from DTO.VulnerabilityQueue import VulnerabilityQueue
from common.dumper import dumper
import service.image_service as manage

class VulnerabilityManager:
    auth_url = 'https://auth.docker.io/token'

    def __init__(self):
        self.worker_status = diskcache.Cache(directory="./cache/worker_status")
        self.scan_result = diskcache.Cache(directory="./cache/scan_result")
        self.auth_token = diskcache.Cache(directory="./cache/auth_token")

    def queue(
            self,
            imageId: str,
    ):
        # list = manage.get_image_list()
        list = manage.print_list()
        target_image = [i for i in list if i['Name'] == imageId]

        if len(target_image) == 0:
            return
        else:
            # There is only one 'target_image' or nothing.
            target_image = target_image[0]

        # target_image = [ { 'id': ..., 'RepoTags': ['ruby:3.1.2'] } ]
        # What I want is just 'ruby'. And there is also only one 'ruby' in 'RepoTags'
        # target_image[0]['RepoTags']   #=> [ 'ruby:3.1.2' ]
        repository_name = target_image['RepoTags'][0].split(':')[0]
        digest = target_image['RepoDigests'][0]
        queue = VulnerabilityQueue(
            uuid=uuid.uuid4().hex,
            imageId=imageId,
            repo_name=repository_name,
            digest=digest,
            token=self.__get_auth_token(repository_name),
            result=None,
        )

        self.worker_status.set(f"Vulnerability_{queue.uuid}", queue, expire=3600)

        return

    def get_queue(self):
        result = []
        for key in self.worker_status.iterkeys():
            if key.startswith("Vulnerability_"):
                vulnerability: VulnerabilityQueue = self.worker_status.get(key=key)
                if vulnerability is None:
                    self.worker_status.delete(key=key)
                    continue

                result.append({
                    "uuid": vulnerability.uuid,
                    "imageId": vulnerability.imageId,
                    "result": vulnerability.result
                })

        return json.loads(json.dumps(result))

    def get_vulnerability(self, key) -> Union[dict, None]:
        vulnerability: VulnerabilityQueue = self.worker_status.get(f"Vulnerability_{uuid}")
        if vulnerability is None:
            self.worker_status.delete(key=key)
            return None

        return {
            "uuid": vulnerability.uuid,
            "imageId": vulnerability.imageId,
            "result": vulnerability.result
        }

    def get_scan_result(self, image_id: str):
        for key in self.scan_result.iterkeys():
            if key.startswith("Vulnerability_"):
                if image_id in key.replace("Vulnerability_", ""):
                    return self.scan_result.get(key=key)

    def get_list(self):
        list = manage.print_list()
        result = []
        for i in list:
            i['vulnerability'] = self.get_scan_result(i['Name'])
            if i['vulnerability'] is not None:
                now = datetime.datetime.now()
                i['scan_date'] = now.strftime('%Y-%m-%d %H:%M:%S')
            else:
                i['scan_date'] = None
            i['state'] = 'not scanned'
            result.append(i)
        return json.loads(json.dumps(result, default=dumper))

    # Private function
    def __get_auth_token(self, repository: str):
        # request for token of 'ch1keen/pwnable': OK
        # request for token of 'library/ruby': OK
        # request for token of 'ruby': 404 Not Found
        if repository.find('/') == -1:
            repository = 'library/' + repository

        token = self.auth_token.get(repository)
        if token == None:
            params = {
                        'service': 'registry.docker.io',
                        'scope': f'repository:{repository}:pull',
                     }
            response = requests.get(self.auth_url, params=params)

            if response.status_code == 200:
                token_json = json.loads(response.content)

                self.auth_token.set(repository, token_json['token'], expire=token_json['expires_in'])
                return token
            else:
                logging.error("Cannot retrieve a token: Received %d" % response.status_code)
                logging.error(json.loads(response.content))
                return None
        else:
            return token

    pass
